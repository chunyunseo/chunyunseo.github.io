I"Ï&<h1 id="1-minimum-cost-spanning-trees">1. Minimum Cost Spanning Trees</h1>

<ul>
  <li>edgeê°€ vertexë³´ë‹¤ í•˜ë‚˜ ë” ì“°ì´ëŠ” ê²ƒ.</li>
  <li>
    <p>ê°€ì¥ weightë¥¼ ì ê²Œ ë¨¹ëŠ” ê²ƒ.</p>
  </li>
  <li>Kruskal Algorithm
    <ul>
      <li>greedyí•œ ë°©ë²•.</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T = {}; //ì²˜ìŒì— TëŠ” í…… ë¹„ì–´ìˆìŒ.
while((Tê°€ n-1ê°œë³´ë‹¤ ì ì€ edgesë¥¼ ê°€ì§ˆ ë•Œ) &amp;&amp; (Eê°€ ë¹„ì–´ìˆì§€ ì•Šì„ ë•Œ))
{
    Eì—ì„œ least cost edge (v, w)ë¥¼ ê³ ë¥¸ë‹¤;
    //í™ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
    
    Eì—ì„œ (v, w)ë¥¼ ì§€ìš´ë‹¤;
    
    //ë””ìŠ¤ì¡°ì¸íŠ¸ ì…‹ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
    if(((v, w)ê°€ Tì—ì„œ cycleì„ ë§Œë“¤ì§€ ì•Šìœ¼ë©´))
        Tì— (v,w)ë¥¼ ë„£ëŠ”ë‹¤;
}

if(Tê°€ n-1ê°œë³´ë‹¤ ì ì€ edgesë¥¼ ê°€ì§€ë©´)
    printf("ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ\n");


</code></pre></div></div>

<ul>
  <li>Prim Algorithm</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T = {};
TV = {0};
while(Tê°€ n-1ê°œë³´ë‹¤ ì ì€ edgeë¥¼ ê°€ì§€ê³  ìˆì„ ë•Œ)
{
    TVì— ì†í•˜ëŠ” uì™€ TVì— ì†í•˜ì§€ ì•ŠëŠ” vì— ëŒ€í•´ì„œ, least cost edge (u, v)ë¥¼ ê³ ë¥¸ë‹¤;
    if(ê·¸ëŸ¬í•œ edgeê°€ ì—†ìœ¼ë©´) break;
    TVì— vë¥¼ ì¶”ê°€í•œë‹¤;
    Tì— (u, v)ë¥¼ ì¶”ê°€í•œë‹¤.
}

if(Tê°€ n-1ë³´ë‹¤ ì ì€ edgesë¥¼ ê°€ì§€ë©´)
    printf("ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ.\n");
</code></pre></div></div>

<ul>
  <li>
    <p>Sollin Algorithm</p>

    <ol>
      <li>
        <p>edgeê°€ ì—†ëŠ” forestë¡œ ì‹œì‘í•œë‹¤.(ëª¨ë“  vertexê°€ ê°ê° treeì„)</p>
      </li>
      <li>
        <p>ê° ìŠ¤í…Œì´ì§€ì—ì„œ Tì— í¬í•¨í•  edgeë¥¼ ê³ ë¥¸ë‹¤.</p>

        <p>1) ë‹¤ë¥¸ componentì™€ ì—°ê²°ë˜ëŠ” least cost edge</p>

        <p>2) ì¤‘ë³µ ì„ íƒì€ ì œê±°ëœë‹¤.</p>
      </li>
    </ol>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/chunyunseo/ImageRepo/image/img/image-20210515013514518.png" alt="image-20210515013514518" /></p>

<p>ìœ„ ê·¸ë¦¼ì—ì„œ stage 1ì—ì„œëŠ” ë¶„í™ìƒ‰ ì„ ë“¤ì´ ì„ íƒëœë‹¤. ê·¸ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì—ì„œëŠ” ì´ˆë¡ìƒ‰ ì„ ë“¤ì´ ì„ íƒëœë‹¤.</p>

<h1 id="2-shortest-path">2. Shortest path</h1>

<ul>
  <li>ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cost</span><span class="p">[][</span><span class="n">MAX_VERTICES</span><span class="p">],</span> <span class="kt">int</span> <span class="n">distance</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">found</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="n">found</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//ì´ˆê¸°í™” ì„¸íŒ…. vëŠ” ì‹œì‘ ì •ì ì„.</span>
    
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
        <span class="c1">//í•´ë‹¹ vertexì™€ ì—°ê²°ëœ ì •ì ì¤‘ì— ê°€ì¥ì‘ì€ ê²ƒì„ ì°¾ìŒ.</span>
        
        <span class="n">found</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
                <span class="k">if</span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
                    <span class="n">distance</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">cost</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">w</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">choose</span><span class="p">(</span><span class="kt">int</span> <span class="n">distance</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">found</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">//ê°€ì¥ ì‘ì€ ì •ì ì„ ì°¾ëŠ” í•¨ìˆ˜.</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">minpos</span><span class="p">;</span>
    <span class="n">min</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
    <span class="n">minpos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">minpos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="k">return</span> <span class="n">minpos</span><span class="p">;</span>
    
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>ë²¨ë§Œí¬ë“œ ì•Œê³ ë¦¬ì¦˜: Negative Edgeê°€ ìˆì„ ë•Œ ë‹¤ìµìŠ¤íŠ¸ë¼ ëŒ€ì‹  ì‚¬ìš©.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void bellman_ford(int n, int v)
{
    for(int i =0; i&lt;n; i++)
        dist[i] = length[v][i];
    //ì´ˆê¸°í™”
    
    for(int k=1; k&lt;=n-1; k++)
    {
        for(u!=vì´ë©´ì„œ ìµœì†Œí•œ í•˜ë‚˜ì˜ incoming edgeë¥¼ ê°€ì§€ëŠ” ê°ê°ì˜ uì— ëŒ€í•´ì„œ)
        {
            for(ê° ì—£ì§€ &lt;i, u&gt;ì— ëŒ€í•´ì„œ)
            {
                if(dist[u] &gt; dist[i] + length[i][u])
                    dist[u] = dist[i] + length[i][u];
            }
		}
    }
    
    for(Eì˜ ê° edge(u,w)ì— ëŒ€í•´ì„œ)
        if(dist[w] &gt; dist[u] + length[u][w]) return FALSE;
    //negative cycle ê°ì§€ ë¶€ë¶„
    
}
</code></pre></div></div>

:ET